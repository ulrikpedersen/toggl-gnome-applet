#!/usr/bin/env python

'''
toggl -- Client application for the Toggl time tracking system.

toggl is a online time tracking system

It defines a commandline client interface.

@author:     Ulrik Kofoed Pedersen
            
@copyright:  2014 All rights reserved.
            
@license:    Do no harm!

@contact:    https://github.com/ulrikpedersen
@deffield    updated: Updated
'''

import sys

import argparse
import logging
import urllib2, base64, json

logging.basicConfig(level=logging.WARNING)

__all__ = []
__version__ = 0.1
__date__ = '2014-01-07'
__updated__ = '2014-01-07'
    
class Application:    
    def __init__(self):
        self.log = logging.getLogger("Application")
        
        self.parser = None # option parser
        self.cli_args = None

        self.program_version = "v%s"%(str(__version__))
        self.program_build_date = "%s" % __updated__
     
        self.program_version_string = '%s (%s)' % (self.program_version, self.program_build_date)
        #program_usage = '''usage: spam two eggs''' # optional - will be autogenerated by optparse
        self.program_longdesc = '''''' # optional - give further explanation about what the program does
        self.program_license = """Copyright 2014 Ulrik Kofoed Pedersen                                            \
Licensed under the Unlicense
http://unlicense.org
"""
    
    def _options(self):
        # setup option parser
        self.parser = argparse.ArgumentParser(description = self.program_license)
        self.parser.add_argument("-v", "--version", action="version", 
                                 version=self.program_license + self.program_version_string, 
                                 help="Display application version")
        self.parser.add_argument('--debug', nargs='?', const="debug", default="warning",
                                 choices=["debug", "info", "warning", "error", "fatal"],
                                 help="Set the application debug logging level (default: warning)")

        subparsers = self.parser.add_subparsers(dest='subcmd')

        # Create the option set for the 'task' sub-command
        sp_task = subparsers.add_parser('task', help='''Start, stop and status of current work task''')
        group = sp_task.add_mutually_exclusive_group() # only allow either a start or stop of task
        group.add_argument('-s','--start', nargs='?', default=False, const='now', help='Start the clock on a given task')
        group.add_argument('-e', '--end', nargs='?', default=False, const='now', help='Stop the clock on the current running task')
        sp_task.add_argument('-p','--project', help = 'Project to clock the time of the current task on')
        sp_task.add_argument('-t','--tag', action='append', dest='tags', help='Tag to attach to this current task')
        sp_task.add_argument('-m','--message', help='Description of the current task')
        sp_task.set_defaults(func=self.task_cmd)

        # Create the option set for the 'list' sub-command
        sp_list = subparsers.add_parser('list', help='''Lists of tags and projects''')
        sp_list.set_defaults(func=self.list_cmd)
        sp_list.add_argument('-p','--projects', action='store_true', help = 'List projects')
        sp_list.add_argument('-t','--tags', action='store_true', help = 'List tags')
        
        # Create the option set for the 'report' sub-command
        sp_report = subparsers.add_parser('report', help='''Report accumulated time per project or tag''')
        sp_report.set_defaults(func=self.report_cmd)
        sp_report.add_argument('--project', help = 'Report time clocked on the given project')
                        
        # process options
        self.cli_args = self.parser.parse_args()
        
        # Set the debug logging level
        self.cli_args.debug = self.cli_args.debug.upper()
        self.log.setLevel(self.cli_args.debug)
        self.log.debug("Set the debug level...")

    def run(self):
        self.log.debug("Its alive!!!")
        #print self.cli_args
        self._options()
        try:
            self.cli_args.func(self.cli_args) # block until finished running sub-command
        except:
            self.log.exception("Failed to complete function... args: %s" % str(self.cli_args))
        
    def task_cmd(self, args=None):
        self.log.debug("Running the \'task\' sub command")
        raise NotImplementedError
    
    def list_cmd(self, args=None):
        self.log.debug("Running the \'list\' sub command")
        raise NotImplementedError

    def report_cmd(self, args=None):
        self.log.debug("Running the \'report\' sub command")
        raise NotImplementedError

class TogglApp(Application):
    _api_token="" # HACK ALERT! My own token used here...
    def __init__(self):
        Application.__init__(self)
        self.log = logging.getLogger("TogglApp")
        
        self.toggl_domain = "www.toggl.com"
        self.toggl_api = "https://%s/api/v8/" % self.toggl_domain
        self.report_api = "https://%s/reports/api/v2" % self.toggl_domain
        tokenfile=open(".toggltoken")
        self._api_token=tokenfile.read().strip() # Read the token as string from file without newlines
        tokenfile.close()

    def send_request( self, api_call_url ):
        ''' Send a request or command to Toggl, retrieve and parse the json response.
        returns a list of dictionary objects.
        Throws an exception if the http response is not OK (200) or if no JSON can be decoded from the response.
        '''
        request = urllib2.Request( api_call_url )
        # username:password
        # Use base64.standard_b64encode instead of replace...
        user_pass = base64.encodestring('%s:%s' % (self._api_token, 'api_token')).replace('\n', '')
        request.add_header("Authorization", "Basic %s" % user_pass)   
        result = urllib2.urlopen(request) # with no data, this is a http GET.
        self.log.debug("http request result: code=%s url=\'%s\'", result.getcode(), result.geturl())
        js = json.load(result)
        self.log.debug("JSON raw result: %s" % json.dumps(js,sort_keys=True, indent=4, separators=(',', ': ')))
        return js
    
    def get_workspace(self, index=0):
        js = self.send_request(self.toggl_api + "workspaces")
        if not (len(js) >= 1):
            index=0
        return js[index]
    
    def get_projects(self):
        self.log.debug("get_projects")
        workspace = self.get_workspace()
        js = self.send_request(self.toggl_api + "workspaces/%(id)s/projects"%workspace)
        return js

    def task_cmd(self, args=None):
        self.log.debug("Running the \'task\' sub command")
    
    def list_cmd(self, args=None):
        self.log.debug("Running the \'list\' sub command")
        if args.projects:
            projects = self.get_projects()
            for project in projects:
                print "%s\t%s" % (project['id'], project['name'])
        elif args.tags:
            raise NotImplementedError
            

    def report_cmd(self, args=None):
        self.log.debug("Running the \'report\' sub command")
        

if __name__ == "__main__":
    app = TogglApp()
    sys.exit(app.run())
    